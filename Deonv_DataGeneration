mport numpy as np
import matplotlib.pyplot as plt

def conv_dec(dec, irf):
    c = np.shape(dec)
#     conv = np.zeros([2 * c - 1])
    conv = np.convolve(dec, irf)
    return conv
    
def norm1D(fn):
    if np.amax(fn) == 0:
        nfn = fn
    else:
        nfn = np.divide(fn, np.amax(fn))
    return nfn
    
def binarize_3d_array(arr, threshold = 0.1):
    """
    Binarize a 3D array based on a given threshold.

    Parameters:
    arr (numpy.ndarray): The input 3D array.
    threshold (float): The threshold value for binarization.

    Returns:
    numpy.ndarray: The binarized 3D array.
    """
    binarized_arr = np.where(arr >= threshold, 1, 0)
    return binarized_arr
    
class lifetimeGen:
    def __init__(self, tau1_lim, tau2_lim, frac1_lim, img):
        self.tau1_lim = tau1_lim
        self.tau2_lim = tau2_lim
        self.frac1_lim = frac1_lim
        self.img = img
            
    def lifetime_gen(self, threshold):
        x, y, sz = np.shape(self.img) #sz is the size of the image stack
        ref = binarize_3d_array(self.img, threshold) #binarize the matrix
        if self.tau1_lim[0] != self.tau1_lim[1]:
            tau1 = ref *np.random.randint(self.tau1_lim[0], self.tau1_lim[1], size = (x, y, sz))*0.01
        else:
            tau1 = ref *self.tau1_lim[0]*0.01
        if self.tau2_lim[0] != self.tau2_lim[1]:
            tau2 = ref *np.random.randint(self.tau2_lim[0], self.tau2_lim[1], size = (x, y, sz))*0.01
        else:
            tau2 = ref *self.tau2_lim[0]*0.01 
        if self.frac1_lim[0] != self.frac1_lim[1]:
            frac1 = ref *np.random.randint(self.frac1_lim[0], self.frac1_lim[1], size = (x, y, sz))*0.01
        else:
            frac1 = ref *self.frac1_lim[0]*0.01 
        frac2 = np.multiply((1 - frac1), ref)
        return tau1, tau2, frac1, frac2

    def decay_gen(self, irf, gw, threshold, PoisN = False, ns= None):  # IRF, Gate_width is actually gate shift here (in ns)
        tau1, tau2, frac1, frac2 = self.lifetime_gen(threshold)
        x, y, sz = np.shape(self.img)      
        a1, b1, c1 = np.shape(irf)
        time_pts = np.arange(0, c1)
        t = time_pts * gw * (10 ** -3)
        t_minus = np.multiply(t, -1)

        dec = np.zeros((x, y, c1, sz)) 
        A = np.zeros((x, y, c1, sz))  
        B = np.zeros((x, y, c1, sz))  
        irf_out = np.zeros((x, y, c1, sz))
        dec_conv =  np.zeros((x, y, 2 * c1 - 1, sz))
        
        for ii in range(sz):
            if ns is None:
                noise = 0
            else:
                rn1 = np.random.randint(ns.shape[0])
                noise = np.concatenate([(ns[rn1,:]),(ns[rn1,:-1])], axis =0) * 0.1
            
            for i in range(x):
                for j in range(y):
                    if np.squeeze(tau1[i, j, ii]) != 0:               
                        A[i, j, :, ii] = np.multiply(frac1[i, j, ii], np.exp(np.divide(t_minus, np.squeeze(tau1[i, j, ii]))))
                    if np.squeeze(tau2[i, j, ii]) != 0:   
                        B [i, j, :, ii] = np.multiply(frac2[i, j, ii], np.exp(np.divide(t_minus, np.squeeze(tau2[i, j, ii]))))
                    dec[i, j, :, ii] = A[i, j, :, ii] + B [i, j, :, ii]
                    irf_out[i, j, :, ii] = norm1D(irf[np.random.randint(a1), np.random.randint(b1), :])
                    dec_conv[i, j, :, ii] = conv_dec(norm1D(np.squeeze(dec[i, j, :, ii])), np.squeeze(irf_out[i, j, :, ii]))
                    if PoisN == True:
                        dec_conv[i, j, :, ii] = np.random.poisson(dec_conv[i, j, :, ii])
                    if dec_conv[i, j, :, ii].all() != 0:
                        dec_conv[i, j, :, ii] += noise
                    dec_conv[i, j, :, ii] = norm1D(np.squeeze(dec_conv[i, j, :, ii]))
        return dec_conv[:,:,:c1, :], tau1, tau2, frac1, frac2, dec, irf_out

gw = 40  # Gate delay in picoseconds
tau1 = [(30, 100), (20, 70), (30, 40), (25, 45)]  # each element in the list suggests the range of short-lifetime
tau2 = [(90, 100), (70, 120), (60, 90), (70, 100)]  # each element in the list suggest the range of long-lifetime
frac1 = [(0, 0), (20, 50), (0, 0), (100, 100)] # each element in the list suggest the range of fraction of short lifetime

# Dummy sequence of images are created with the intensity range of 0-255 and size of each image is 28 x 28
img_stack = np.random.randint(0,255, size=(28, 28, 4)) # replace this with your database
irf = np.random.randint(20,50, size=(5, 46, 201)) # replace this with your system IRF
gw = 40  # Gate delay in each sequence in time-resolved imaging
threshold = 0.1


p=1
ltGen = lifetimeGen(tau1[p], tau2[p], frac1[p], img_stack)
dec_conv, tau1, tau2, frac1, frac2, dec, irf_out = ltGen.decay_gen(irf, gw, threshold, PoisN = False, ns= ns)

Ploting to check the data

i = tau1.shape[2] # number of rows in the subplots
j = 6 # number of columns in the subplots
ax1 = 20
ay1 = 12
cmaps = ['RdBu_r', 'viridis']
# k = 0
fig, axs = plt.subplots(i,j, figsize=(10,4))
k=0
for rows in range(i):
    pcm1 = axs[rows,0].plot(np.squeeze(dec_conv[ax1,ay1,:,k]))
    pcm2 = axs[rows,1].plot(np.squeeze(dec[ax1,ay1,:,k]))
    pcm3 = axs[rows,2].imshow(np.squeeze(tau1[:,:,k]))
    fig.colorbar(pcm3, ax=axs[rows,2])
    pcm3.set_clim(0,1.5)
    pcm4 = axs[rows,3].imshow(np.squeeze(tau2[:,:,k]))
    fig.colorbar(pcm4, ax=axs[rows,3])
    pcm4.set_clim(0,1.5)
    pcm5 = axs[rows,4].imshow(np.squeeze(frac1[:,:,k]))
    fig.colorbar(pcm5, ax=axs[rows,4])
    pcm5.set_clim(0,1)
    pcm6 = axs[rows,5].imshow(np.squeeze(frac2[:,:,k]))
    fig.colorbar(pcm6, ax=axs[rows,5])
    pcm6.set_clim(0,1)
    
    k += 1
